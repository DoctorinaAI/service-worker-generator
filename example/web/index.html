<!DOCTYPE html>
<html>

<head>
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="Service Worker Example">
  <meta flt-viewport="" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="sw_example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png" />

  <title>Service Worker</title>
  <link rel="manifest" href="manifest.json">
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #764ba2;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #loading {
      text-align: center;
      color: white;
      max-width: 90vw;
      animation: fadeIn 0.6s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .logo-container {
      position: relative;
      display: inline-block;
      margin-bottom: 2rem;
    }

    .logo-image {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease;
    }

    .logo-image:hover {
      transform: scale(1.05);
    }

    .progress-ring {
      position: absolute;
      top: -10px;
      left: -10px;
      width: 140px;
      height: 140px;
      transform: rotate(-90deg);
    }

    .progress-ring-circle {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 4;
    }

    .progress-ring-progress {
      fill: none;
      stroke: #00ff88;
      stroke-width: 4;
      stroke-linecap: round;
      stroke-dasharray: 439.823;
      stroke-dashoffset: 439.823;
      transition: stroke-dashoffset 0.3s ease;
      filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.5));
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 300;
      margin: 0 0 1rem 0;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .progress-text {
      font-size: 1.1rem;
      opacity: 0.9;
      margin-top: 1rem;
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      color: #b0b0b0;
    }

    .progress-percentage {
      font-size: 0.9rem;
      opacity: 0.7;
      margin-top: 0.5rem;
      font-weight: 400;
      color: #b0b0b0;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      transition: color 0.3s ease;
    }

    .loading-dots {
      display: inline-block;
      margin-left: 5px;
    }

    .loading-dots::after {
      content: '';
      animation: dots 1.5s infinite;
    }

    /* Resources container */
    .resources-container {
      margin-top: 1rem;
      width: 320px;
      max-height: 0; /* по умолчанию скрыт */
      overflow-y: auto;
      transition: max-height 0.3s ease;
    }

    /* Resource tile */
    .resource-tile {
      height: 64px;
      padding: 4px 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Name of the resource */
    .resource-key {
      font-size: 0.9rem;
      color: #ffffff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Progress bar for each resource */
    .resource-progress-wrapper {
      position: relative;
      background: rgba(255, 255, 255, 0.1);
      height: 24px;
      margin-top: 4px;
      border-radius: 8px;
      overflow: hidden;
    }

    /* Progress bar */
    .resource-progress-bar {
      height: 100%;
      width: 0;
      background: #00ff88;
      transition: width 0.3s ease;
    }

    /* Text for progress bar */
    .resource-progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.7rem;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }

    /* Resouces Firefox */
    .resources-container {
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.4) transparent;
    }

    /* Resouces WebKit */
    .resources-container::-webkit-scrollbar {
      width: 6px;
    }

    .resources-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .resources-container::-webkit-scrollbar-thumb {
      background-color: rgba(255,255,255,0.4);
      border-radius: 3px;
      border: 1px solid transparent;
      background-clip: content-box;
    }

    .resources-container::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255,255,255,0.6);
    }

    @keyframes dots {
      0%, 20% { content: ''; }
      40% { content: '.'; }
      60% { content: '..'; }
      80%, 100% { content: '...'; }
    }

    @media (prefers-color-scheme: dark) { }

    @media (max-width: 480px) {
      .logo-image {
        width: 100px;
        height: 100px;
      }

      .progress-ring {
        width: 120px;
        height: 120px;
        top: -10px;
        left: -10px;
      }

      h1 {
        font-size: 2rem;
      }

      .progress-text {
        font-size: 1rem;
      }

      .resources-container {
        width: 90vw;
      }
    }
  </style>

  <!-- Enable WASM threads on debug: https://github.com/orgs/community/discussions/13309#discussioncomment-3844940 -->
  <script>
    if (!window.crossOriginIsolated && ['localhost', '127.0.0.1'].includes(location.hostname)) {
      const script = document.createElement('script');
      script.src = 'enable-wasm-threads.js';
      document.head.appendChild(script);
    }
  </script>
</head>

<body>
  <!-- Loading indicator -->
  <div id="loading">
    <div class="logo-container">
      <svg class="progress-ring" viewBox="0 0 140 140">
        <circle class="progress-ring-circle" cx="70" cy="70" r="65"></circle>
        <circle class="progress-ring-progress" cx="70" cy="70" r="65" id="progress-circle"></circle>
      </svg>
      <img src="icons/Icon-192.png" class="logo-image" alt="App Logo">
    </div>
    <h1>Service Worker</h1>
    <div class="progress-text" id="progress-text">Initializing<span class="loading-dots"></span></div>
    <div class="progress-percentage" id="progress-percentage">0%</div>
    <div id="resources-container" class="resources-container"></div>
  </div>

  <!-- Flutter JS and build config -->
  <script>
    // Progress management
    let currentProgress = 0;
    let isServiceWorkerAvailable = false;
    let totalResourcesSize = 0; // Total size from sw.js RESOURCES_SIZE
    let loadedResources = new Map(); // Track loaded resources: resourceKey -> { size, loaded }

    const progressCircle = document.getElementById('progress-circle');
    const progressText = document.getElementById('progress-text');
    const progressPercentage = document.getElementById('progress-percentage');
    const circumference = 2 * Math.PI * 65; // radius = 65

    // Initialize progress ring
    progressCircle.style.strokeDasharray = circumference;
    progressCircle.style.strokeDashoffset = circumference;

    /**
     * Calculates the total loaded resources size.
     * Returns the total loaded size from the loadedResources map.
     */
    function calculateTotalProgress() {
      let totalLoaded = 0;
      loadedResources.forEach(resource => {
        totalLoaded += resource.loaded;
      });
      return totalLoaded;
    }

    /**
     * Updates the progress ring and text.
     * @param {number} value - Progress value (0-100).
     * @param {string} text - Optional text to display.
     */
    function updateLoadingProgress(value, text = '') {
      currentProgress = Math.min(Math.max(value, 0), 100);

      // Update circular progress
      const offset = circumference - (currentProgress / 100) * circumference;
      progressCircle.style.strokeDashoffset = offset;

      // Update text
      progressPercentage.textContent = `${Math.round(currentProgress)}%`;
      if (text) progressText.innerHTML = `${text}<span class="loading-dots"></span>`;

      // Console logging
      console.log(`Loading progress: ${Math.round(currentProgress)}% - ${text || 'Loading'}`);
    }

    /**
     * Removes the loading widget with a fade-out effect.
     * This function is called when the app is ready.
     */
    function removeLoadingIndicator() {
      const loadingEl = document.getElementById("loading");
      if (!loadingEl) return;
      loadingEl.remove();
    }

    // Expose functions globally
    window.updateLoadingProgress = updateLoadingProgress;
    window.removeLoadingIndicator = removeLoadingIndicator;

    /**
     * Registers the service worker and listens for messages.
     * Updates progress based on service worker messages.
     */
    async function registerServiceWorker() {
      if ('serviceWorker' in navigator) {
        try {
          const registration = await navigator.serviceWorker.register('/flutter_service_worker.js');
          console.log('Service Worker registered successfully');
          isServiceWorkerAvailable = true; // Listen for service worker messages
          navigator.serviceWorker.addEventListener('message', (event) => {
            if (event.data && event.data?.type === 'sw-progress') {
              const {
                resourceKey,
                resourceUrl,
                resourceName,
                resourceSize,
                resourcesSize,
                timestamp,
                loaded,
                status
              } = event.data;

              totalResourcesSize = resourcesSize || totalResourcesSize; // Update total size if provided

              if (resourceKey && resourceSize !== undefined && loaded !== undefined) {
                // Update or add resource in our hash table
                loadedResources.set(resourceKey, {
                  name: resourceName || resourceKey, // Use resourceName if available
                  key: resourceKey, // Unique key for the resource
                  size: resourceSize, // Size of the resource in bytes
                  loaded: loaded, // Bytes loaded so far
                  url: resourceUrl, // URL of the resource
                  status: status, // installing | fetching
                  timestamp: timestamp || Date.now() // Timestamp of the last update
                });

                // Calculate total progress
                const totalLoaded = calculateTotalProgress();
                const progressPercent = Math.min((totalLoaded / totalResourcesSize) * 100, 100);

                // Map SW progress from 10% to 90% (leaving 10% for dart logic)
                const mappedProgress = 10 + (progressPercent * 0.8); // 10% + (0-100% * 80%)

                let progressText = 'Downloading';
                if (totalLoaded > 0) {
                  const loadedMB = (totalLoaded / 1024 / 1024).toFixed(1);
                  const totalMB = (totalResourcesSize / 1024 / 1024).toFixed(1);
                  //const resourceCount = loadedResources.size;
                  progressText = `Downloading (${loadedMB}/${totalMB} MB)`;
                }

                updateLoadingProgress(mappedProgress, progressText);
              }

              renderResourcesList();
            }
          });

          return registration;
        } catch (error) {
          console.warn('Service Worker registration failed:', error);
          isServiceWorkerAvailable = false;
          return null;
        }
      } else {
        console.warn('Service Workers are not supported');
        isServiceWorkerAvailable = false;
        return null;
      }
    }

    /**
     * Loads the Flutter application.
     * Initializes the Flutter engine and runs the app.
     */
    async function loadFlutterApp() {
      // This tag is replaced by the Flutter build system
      {{flutter_js}}
      {{flutter_build_config}}

      const searchParams = new URLSearchParams(window.location.search);
      const renderer = searchParams.get('renderer');
      const userConfig = renderer ? { 'renderer': renderer } : {};

      try {
        await _flutter.loader.load({
          config: userConfig,
          onEntrypointLoaded: async function(engineInitializer) {
            if (!isServiceWorkerAvailable) {
              // Fallback progress without service worker
              updateLoadingProgress(30, 'Initializing Flutter engine');
            }

            const appRunner = await engineInitializer.initializeEngine();
            updateLoadingProgress(90, 'Starting application');
            await appRunner.runApp();
          }
        });
      } catch (error) {
        console.error('Failed to initialize Flutter app:', error);
        updateLoadingProgress(0, 'Failed to load application');
      }
    }

    /**
     * Initializes the Flutter application.
     * Registers the service worker and loads the Flutter engine.
     */
    async function initializeApp() {
      try {
        updateLoadingProgress(0, 'Loading flutter application');
        loadFlutterApp();

        // Register service worker first
        updateLoadingProgress(10, 'Registering service worker');
        await registerServiceWorker();

        /* updateLoadingProgress(10, 'Loading flutter application');
        if ('serviceWorker' in navigator) {
          if (navigator.serviceWorker.controller) {
            console.log('[SW] registered and controlled');
            loadFlutterApp(); // Load Flutter app immediately if already controlled
          } else {
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              console.log('[SW] controller changed — now controlled');
              loadFlutterApp(); // Load Flutter app after service worker takes control
            });
          }
        } else {
          console.warn('[SW] Service Worker not supported, loading Flutter app directly');
          loadFlutterApp(); // Load Flutter app directly if service worker is not supported
        } */
      } catch (e) {
        console.error('[SW] registration failed:', e);
        loadFlutterApp(); // Load Flutter app even if service worker registration fails
      }
    }

    // Event listeners
    window.addEventListener('load', function () {
      initializeApp();
    });

    // Listen for the first frame event to finalize loading
    window.addEventListener('flutter-first-frame', function () {
      const loadingEl = document.getElementById("loading");
      if (!loadingEl) return;
      loadingEl.remove();
    });

    // Handle service worker updates,
    // reloading the page when a new service worker takes control.
    //if ('serviceWorker' in navigator) {
    //  navigator.serviceWorker.addEventListener('controllerchange', () => {
    //    console.log('Service Worker updated, reloading page...');
    //    window.location.reload();
    //  });
    //}

    /**
     * Formats bytes into a human-readable string.
     * @param {number} bytes - The number of bytes.
     * @param {number} [decimals=1] - Number of decimal places to show.
     */
    function formatBytes(bytes, decimals = 1) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    /**
     * Draws the list of resources with their loading progress.
     */
    function renderResourcesList() {
      const container = document.getElementById('resources-container');
      if (!container) return;
      container.innerHTML = '';
      // Sort resources by timestamp (most recent first)
      const sortedResources = Array.from(loadedResources.values())
        .filter(res => res.size > 0).sort((a, b) => b.timestamp - a.timestamp);
      if (sortedResources.length === 0) {
        container.innerHTML = '<div class="resource-tile">No resources loaded yet</div>';
        return;
      }
      sortedResources.forEach(res => {
        const tile = document.createElement('div');
        tile.className = 'resource-tile';

        const title = document.createElement('div');
        title.className = 'resource-key';
        title.textContent = res.name || res.key || res.url || 'Unknown';

        const wrapper = document.createElement('div');
        wrapper.className = 'resource-progress-wrapper';

        const bar = document.createElement('div');
        bar.className = 'resource-progress-bar';
        const percent = res.size ? (res.loaded / res.size) * 100 : 0;
        bar.style.width = `${percent}%`;

        const overlay = document.createElement('div');
        overlay.className = 'resource-progress-text';
        overlay.textContent = `${res.status} ${formatBytes(res.loaded)} / ${formatBytes(res.size)}`;

        wrapper.append(bar, overlay);
        tile.append(title, wrapper);
        container.append(tile);
      });

      adjustResourcesContainerHeight();
    }

    /**
     * Show or hide the resources container based on available height
     */
    function adjustResourcesContainerHeight() {
      const container = document.getElementById('resources-container');
      const loading = document.getElementById('loading');
      const viewportH = window.innerHeight;
      const loadingRect = loading.getBoundingClientRect();
      const available = viewportH - loadingRect.top - loadingRect.height - 20; // отступ 20px

      if (available >= 64) {
        container.style.maxHeight = `${available}px`;
      } else {
        container.style.maxHeight = '0';
      }
    }

    // Подстраиваем на ресайз
    window.addEventListener('resize', adjustResourcesContainerHeight);
  </script>
</body>
</html>