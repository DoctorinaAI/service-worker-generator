<!DOCTYPE html>
<html>

<head>
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="Service Worker Example">
  <meta flt-viewport="" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="sw_example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png" />

  <title>Service Worker</title>
  <link rel="manifest" href="manifest.json">
  <style type="text/css">
    body,
    html {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #764ba2;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #loading {
      text-align: center;
      color: white;
      max-width: 90vw;
      animation: fadeIn 0.6s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .logo-container {
      position: relative;
      display: inline-block;
      margin-bottom: 2rem;
    }

    .logo-image {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease;
    }

    .logo-image:hover {
      transform: scale(1.05);
    }

    .progress-ring {
      position: absolute;
      top: -10px;
      left: -10px;
      width: 140px;
      height: 140px;
      transform: rotate(-90deg);
    }

    .progress-ring-circle {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 4;
    }

    .progress-ring-progress {
      fill: none;
      stroke: #00ff88;
      stroke-width: 4;
      stroke-linecap: round;
      stroke-dasharray: 439.823;
      stroke-dashoffset: 439.823;
      transition: stroke-dashoffset 0.3s ease;
      filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.5));
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 300;
      margin: 0 0 1rem 0;
      letter-spacing: 0.5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .progress-text {
      font-size: 1.1rem;
      opacity: 0.9;
      margin-top: 1rem;
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      color: #b0b0b0;
    }

    .progress-percentage {
      font-size: 0.9rem;
      opacity: 0.7;
      margin-top: 0.5rem;
      font-weight: 400;
      color: #b0b0b0;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      transition: color 0.3s ease;
    }

    .loading-dots {
      display: inline-block;
      margin-left: 5px;
    }

    .loading-dots::after {
      content: '';
      animation: dots 1.5s infinite;
    }

    @keyframes dots {

      0%,
      20% {
        content: '';
      }

      40% {
        content: '.';
      }

      60% {
        content: '..';
      }

      80%,
      100% {
        content: '...';
      }
    }

    @media (prefers-color-scheme: dark) {}

    @media (max-width: 480px) {
      .logo-image {
        width: 100px;
        height: 100px;
      }

      .progress-ring {
        width: 120px;
        height: 120px;
        top: -10px;
        left: -10px;
      }

      h1 {
        font-size: 2rem;
      }

      .progress-text {
        font-size: 1rem;
      }
    }
  </style>

  <!-- Enable WASM threads on debug: https://github.com/orgs/community/discussions/13309#discussioncomment-3844940 -->
  <script>
    if (!window.crossOriginIsolated && ['localhost', '127.0.0.1'].includes(location.hostname)) {
      const script = document.createElement('script');
      script.src = 'enable-wasm-threads.js';
      document.head.appendChild(script);
    }
  </script>
</head>

<body>
  <!-- Loading indicator -->
  <div id="loading">
    <div class="logo-container">
      <svg class="progress-ring" viewBox="0 0 140 140">
        <circle class="progress-ring-circle" cx="70" cy="70" r="65"></circle>
        <circle class="progress-ring-progress" cx="70" cy="70" r="65" id="progress-circle"></circle>
      </svg>
      <img src="icons/Icon-192.png" class="logo-image" alt="App Logo">
    </div>
    <h1>Service Worker</h1>
    <div class="progress-text" id="progress-text">Initializing<span class="loading-dots"></span></div>
    <div class="progress-percentage" id="progress-percentage">0%</div>
    <div id="resources-container" class="resources-container"></div>
  </div>

  <script>
    // Progress management
    let currentProgress = 0;
    let isServiceWorkerAvailable = false;
    let totalResourcesSize = 0; // Total size from sw.js RESOURCES_SIZE
    let loadedResources = new Map(); // Track loaded resources: resourceKey -> { size, loaded }
    let serviceWorkerMessageHandler = null; // Store reference to the message handler for cleanup

    const progressCircle = document.getElementById('progress-circle');
    const progressText = document.getElementById('progress-text');
    const progressPercentage = document.getElementById('progress-percentage');
    const circumference = 2 * Math.PI * 65; // radius = 65

    // Initialize progress ring
    progressCircle.style.strokeDasharray = circumference;
    progressCircle.style.strokeDashoffset = circumference;

    /**
     * Calculates the total loaded resources size.
     * Returns the total loaded size from the loadedResources map.
     */
    function calculateTotalLoaded() {
      let totalLoaded = 0;
      loadedResources.forEach(resource => {
        totalLoaded += resource.loaded || 0; // Use loaded bytes if available
      });
      return totalLoaded;
    }

    /**
     * Calculates the total size of all resources.
     * Returns the total size from the loadedResources map.
     */
    function calculateTotalSize() {
      let totalSize = 0;
      loadedResources.forEach(resource => {
        totalSize += resource.size || 0; // Use resource size if available
      });
      // Ensure at least 8 MB total size if no resources are loaded yet
      return Math.max(totalSize, 8 * 1024 * 1024);
    }

    /**
     * Updates the progress ring and text.
     * @param {number} value - Progress value (0-100).
     * @param {string} text - Optional text to display.
     */
    function updateLoadingProgress(value, text = '') {
      currentProgress = Math.min(Math.max(value, 0), 100);

      // Update circular progress
      const offset = circumference - (currentProgress / 100) * circumference;
      progressCircle.style.strokeDashoffset = offset;

      // Update text
      progressPercentage.textContent = `${Math.round(currentProgress)}%`;
      if (text) progressText.innerHTML = `${text}<span class="loading-dots"></span>`;

      // Console logging
      console.log(`Loading progress: ${Math.round(currentProgress)}% - ${text || 'Loading'}`);
    }

    /**
     * Removes the loading widget with a fade-out effect.
     * This function is called when the app is ready.
     */
    function removeLoadingIndicator() {
      const loadingEl = document.getElementById("loading");
      if (!loadingEl) return;
      loadingEl.remove();
    }

    // Expose functions globally
    window.updateLoadingProgress = updateLoadingProgress;
    window.removeLoadingIndicator = removeLoadingIndicator;

    /**
     * Registers the service worker and listens for messages.
     * Updates progress based on service worker messages.
     */
    async function registerServiceWorker() {
      const swVersion = {{flutter_service_worker_version}};
      if (!swVersion) {
        console.log('Service Worker not registered (no version or non-production build).');
        isServiceWorkerAvailable = false;
        return;
      }
      if (!('serviceWorker' in navigator)) {
        console.warn('Service Workers are not supported in this browser');
        isServiceWorkerAvailable = false;
        return;
      }

      try {
        const swUrl = `sw.js?v=${swVersion}`;
        const registration = await navigator.serviceWorker.register(swUrl);
        console.log('Service Worker registered successfully');
        isServiceWorkerAvailable = true;

        // Create and store the message handler for later cleanup
        serviceWorkerMessageHandler = (event) => {
          if (event.data && event.data?.type === 'sw-progress') {
            const {
              resourceKey,
              resourceUrl,
              resourceName,
              resourceSize,
              resourcesSize,
              timestamp,
              loaded,
              status
            } = event.data;

            //totalResourcesSize = resourcesSize || totalResourcesSize; // Update total size if provided

            if (resourceKey && resourceSize !== undefined && loaded !== undefined) {
              // Update or add resource in our hash table
              loadedResources.set(resourceKey, {
                name: resourceName || resourceKey, // Use resourceName if available
                key: resourceKey, // Unique key for the resource
                size: resourceSize, // Size of the resource in bytes
                loaded: loaded, // Bytes loaded so far
                url: resourceUrl, // URL of the resource
                status: status, // installing | fetching
                timestamp: timestamp || Date.now() // Timestamp of the last update
              });

              // Calculate total progress
              const totalLoaded = calculateTotalLoaded();
              const totalSize = calculateTotalSize();
              const progressPercent = Math.min((totalLoaded / totalSize) * 100, 100);

              // Map SW progress from 10% to 90% (leaving 10% for dart logic)
              const mappedProgress = 10 + (progressPercent * 0.8); // 10% + (0-100% * 80%)

              console.log(`Downloading resource "${resourceName}" (${formatBytes(loaded)} / ${formatBytes(resourceSize)})`);

              let progressText = 'Downloading';
              if (totalLoaded > 0) {
                //const resourceCount = loadedResources.size;
                progressText = `Downloading (${formatBytes(totalLoaded)} / ${formatBytes(totalSize)})`;
              }

              // Update the loading progress only if it's below 90%
              // Because we reserve 10% for the Dart logic
              if (currentProgress <= 90)
                updateLoadingProgress(mappedProgress, progressText);
            }
          }
        };

        // Listen for service worker messages
        navigator.serviceWorker.addEventListener('message', serviceWorkerMessageHandler);
      } catch (error) {
        console.warn('Service Worker registration failed:', error);
        isServiceWorkerAvailable = false;
      }
    }

    /**
     * Loads the Flutter application.
     * Initializes the Flutter engine and runs the app.
     */
    async function loadFlutterApp() {
      // This tag is replaced by the Flutter build system
      {{flutter_js}}
      {{flutter_build_config}}

      // Register service worker first
      updateLoadingProgress(10, 'Registering service worker');
      await registerServiceWorker();

      const searchParams = new URLSearchParams(window.location.search);
      const renderer = searchParams.get('renderer');
      const userConfig = renderer ? { 'renderer': renderer } : {};

      try {
        await _flutter.loader.load({
          config: userConfig,
          onEntrypointLoaded: async function(engineInitializer) {
            if (!isServiceWorkerAvailable) {
              // Fallback progress without service worker
              updateLoadingProgress(30, 'Initializing Flutter engine');
            }

            // Initialize the Flutter engine
            const appRunner = await engineInitializer.initializeEngine();

            // Clean up service worker message listener
            if (serviceWorkerMessageHandler && 'serviceWorker' in navigator) {
              navigator.serviceWorker.removeEventListener('message', serviceWorkerMessageHandler);
              serviceWorkerMessageHandler = null;
              console.log('Service Worker message listener removed');
            }

            // Set the loading progress to 90% before running the app
            updateLoadingProgress(90, 'Starting application');

            // Run the Flutter application, and initialize
            // the last 10% of the loading progress
            await appRunner.runApp();
          }
        });
      } catch (error) {
        console.error('Failed to initialize Flutter app:', error);
        updateLoadingProgress(0, 'Failed to load application');
      }
    }

    /**
     * Initializes the Flutter application.
     * Registers the service worker and loads the Flutter engine.
     */
    async function initializeApp() {
      try {
        updateLoadingProgress(0, 'Loading flutter application');
        loadFlutterApp();

        /* updateLoadingProgress(10, 'Loading flutter application');
        if ('serviceWorker' in navigator) {
          if (navigator.serviceWorker.controller) {
            console.log('[SW] registered and controlled');
            loadFlutterApp(); // Load Flutter app immediately if already controlled
          } else {
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              console.log('[SW] controller changed — now controlled');
              loadFlutterApp(); // Load Flutter app after service worker takes control
            });
          }
        } else {
          console.warn('[SW] Service Worker not supported, loading Flutter app directly');
          loadFlutterApp(); // Load Flutter app directly if service worker is not supported
        } */
      } catch (e) {
        console.error('[SW] registration failed:', e);
        loadFlutterApp(); // Load Flutter app even if service worker registration fails
      }
    }

    // Event listeners
    window.addEventListener('load', function () {
      initializeApp();
    }, { once: true });

    // Listen for the first frame event to finalize loading
    window.addEventListener('flutter-first-frame', function () {
      const loadingEl = document.getElementById("loading");
      if (!loadingEl) return;
      loadingEl.remove();
    }, { once: true });

    // Handle service worker updates,
    // reloading the page when a new service worker takes control.
    //if ('serviceWorker' in navigator) {
    //  navigator.serviceWorker.addEventListener('controllerchange', () => {
    //    console.log('Service Worker updated, reloading page...');
    //    window.location.reload();
    //  });
    //}

    /**
     * Formats bytes into a human-readable string.
     * @param {number} bytes - The number of bytes.
     * @param {number} [decimals=1] - Number of decimal places to show.
     */
    function formatBytes(bytes, decimals = 1) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
  </script>
</body>
</html>